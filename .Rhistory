n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
p <- draw_params(param_mean, param_sd)
p
p
pars <- model_def$map(p)
pars <- p
j=1
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- draw_params(param_mean, param_sd)
pars <- p
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
out
}
# --------- RUN IT ----------
N <- 200  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
models <- list(
`FvCB (1980)` = list(
fun  = FvCB1980,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"],
alpha_J=p["alphaJ"], theta_J=p["thetaJ"], V_tpu=p["Vtpu"]
)
),
`Harley (1992)` = list(
fun  = Harley1992,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"], gm=p["gm"]
)
),
`Ethier & Long (2004)` = list(
fun  = EthierLong2004,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"],
gm=p["gm"], alpha_J=p["alphaJ"], theta_J=p["thetaJ"]
)
),
`von Caemmerer (2000)` = list(
fun  = Caemmerer2000,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"],
alpha_J=p["alphaJ"], theta_J=p["thetaJ"],
V_tpu=p["Vtpu"], alpha_tpu=p["atpu"]
)
),
`Yin (2004)` = list(
fun  = Yin2004,
map  = function(p) {
phi2m <- if (!is.na(p["phi2"])) p["phi2"] else 0.85
list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"],
theta_J=p["thetaJ"], phi2m = phi2m,
f_Q = p["fQ"], f_pseudo = p["fpseudo"], f_cyc = p["fcyc"], h = p["h"]
)
}
),
`Dubois (2007)` = list(
fun  = Dubois2007,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["J"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"]
)
)
)
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- draw_params(param_mean, param_sd)
pars <- p
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
out
}
# --------- RUN IT ----------
N <- 200  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- draw_params(param_mean, param_sd)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
out
}
# --------- RUN IT ----------
N <- 200  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
# --------- RUN IT ----------
N <- 5  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
models <- list(
`FvCB (1980)` = list(
fun  = FvCB1980,
map  = function(p) list(
V_cmax=p["Vcmax"], J_max=p["Jmax"], R_d=p["Rd"],
K_C=p["KC"], K_O=p["KO"], gamma_star=p["Gstar"],
alpha_J=p["alphaJ"], theta_J=p["thetaJ"], V_tpu=p["Vtpu"]
)
)
)
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- draw_params(param_mean, param_sd)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
out
}
# --------- RUN IT ----------
N <- 5  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
View(result_arrays)
result_arrays[["FvCB (1980)"]]
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
View(models)
library(truncnorm)
install.packages("truncnorm")
# Mean parameters
param_mean <- c(
Vcmax = 70,
Jmax  = 130,
J     = 130,
Rd    = 2,
KC    = 270,
KO    = 165,
Gstar = 38,
alphaJ = 0.3,
thetaJ = 0.8,
Vtpu   = 9,
gm     = 0.3,
atpu   = 0.3,
phi2m   = 0.85,  # will map to phi2m where needed
fQ     = 1,
fpseudo = 0,
fcyc    = NA_real_, # if NA we set to 1 - fQ - fpseudo
h       = 14
)
# SDs for sampling (tweak as you like)
param_sd <- c(
Vcmax = 7,   Jmax = 13,  J = 13,
Rd    = 0.3, KC   = 30,  KO = 25,
Gstar = 4,   alphaJ= 0.05, thetaJ=0.05,
Vtpu  = 1,   gm    = 0.05, atpu = 0.05,
phi2  = 0.05, fQ = 0, fpseudo = 0,
fcyc  = NA_real_, h = 1.5
)
library(dplyr)
library(purrr)
library(truncnorm)
devtools::load_all()
models <- load_FvCBmodels()
# Grids
Ci     <- c(20,50,100,150,200,300,400,500,600,700,800,1000,1200)
PPFDs  <- c(20,100,300,500,700,1000,1200,1500)
envs_template <- list(
C_i = Ci,
O   = rep(210, length(Ci))
)
# Mean parameters
param_mean <- c(
Vcmax = 70,
Jmax  = 130,
J     = 130,
Rd    = 2,
KC    = 270,
KO    = 165,
Gstar = 38,
alphaJ = 0.3,
thetaJ = 0.8,
Vtpu   = 9,
gm     = 0.3,
atpu   = 0.3,
phi2m   = 0.85,  # will map to phi2m where needed
fQ     = 1,
fpseudo = 0,
fcyc    = NA_real_, # if NA we set to 1 - fQ - fpseudo
h       = 14
)
draw_params <- function(param_mean, pct_range = 0.1) {
p <- sapply(param_mean, function(mu) {
lo <- mu * (1 - pct_range)
hi <- mu * (1 + pct_range)
runif(1, min = lo, max = hi)
})
p["fcyc"] <- NA_real_
return(p)
}
sample_params <- function(param_mean, pct_range = 0.1) {
p <- sapply(param_mean, function(mu) {
lo <- mu * (1 - pct_range)
hi <- mu * (1 + pct_range)
runif(1, min = lo, max = hi)
})
p["fcyc"] <- NA_real_
return(p)
}
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- sample_params(param_mean, 10)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
out
}
# --------- RUN IT ----------
N <- 5  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
View(result_arrays)
warnings()
result_arrays[["FvCB (1980)"]]
source("~/GitHub/FvCBestimation/R/load_FvCBmodels.R", echo = TRUE)
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- sample_params(param_mean, 10)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
return(out)
}
# --------- RUN IT ----------
N <- 5  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean, param_sd))
View(result_arrays)
models <- load_FvCBmodels()
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean, param_sd){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- sample_params(param_mean, 10)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
return(out)
}
View(result_arrays)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_all_models.R", echo = TRUE)
warnings()
model_def <- models[[2]]
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
p <- sample_params(param_mean, 10)
p
param_mean
# Run N samples for ONE model -> 3D array [Ci, PPFD, samples]
simulate_model_samples <- function(model_def, N, envs_template, Ci, PPFDs,param_mean){
n_ci   <- length(Ci)
n_ppfd <- length(PPFDs)
out <- array(NA_real_, dim = c(n_ci, n_ppfd, N),
dimnames = list(Ci = as.character(Ci),
PPFD = as.character(PPFDs),
sample = paste0("s", seq_len(N))))
for (s in seq_len(N)) {
p <- sample_params(param_mean, 0.1)
pars <- model_def$map(p)
for (j in seq_along(PPFDs)) {
envs <- envs_template
envs$PPFD <- rep(PPFDs[j], length(Ci))
res <- model_def$fun(envs = envs, pars = pars)
A   <- res$An
if (length(A) != n_ci) {
stop("Model returned A of length ", length(A), " but expected ", n_ci)
}
out[, j, s] <- A
}
}
return(out)
}
# --------- RUN IT ----------
N <- 5  # number of parameter samples
result_arrays <- imap(models, ~ simulate_model_samples(.x, N, envs_template, Ci, PPFDs,param_mean))
View(result_arrays)
result_arrays[["FvCB (1980)"]]
library(ggplot2)
library(tidyr)
library(dplyr)
library(ggpubr)
devtools::load_all()
Ci <- c(20,50,100,150,200,300,400,500,600,700,800, 1000, 1200)
envs <- list(
C_i = Ci,
PPFD = rep(1500,length(Ci)),
O = rep(210,length(Ci)))
pars <- list(
V_cmax = 70,
J_max = 130,
K_C = 274,
K_O = 420,
R_d = 0.5,
gamma_star = 43,
gm = 0.5
)
ret = list()
Amin <- numeric(length(envs$C_i))
limiting_factor <- character(length(envs$C_i))
ret$Ac <- numeric(length(envs$C_i))
ret$Aj <- numeric(length(envs$C_i))
pars$K_CO <- pars$K_C * (1 + envs$O / pars$K_O)
b <- - (pars$alpha_J * envs$PPFD + pars$J_max)
J <- (- b - sqrt((b)^2 - 4 * pars$theta_J * pars$alpha_J * envs$PPFD * pars$J_max)) / (2 * pars$theta_J)
# quadratic form of Ac from equation 3
a <- -1 / pars$gm
b <- ((pars$V_cmax - pars$R_d) / pars$gm) + envs$C_i + pars$K_CO
c <- pars$R_d * (envs$C_i + pars$K_CO) - pars$V_cmax * (envs$C_i - pars$gamma_star)
sqrt_term <- sqrt(b^2 - 4 * a * c)
ret$Ac <- (-b + sqrt_term) / (2 * a)
# quadratic form of Aj from equation
a <- -4 / pars$gm
b <- 4 * (envs$C_i + 2 * pars$gamma_star) - 4 * pars$R_d/pars$gm +  J/pars$gm
c <- 4 * pars$R_d * (envs$C_i + 2 * pars$gamma_star) - J * (envs$C_i - pars$gamma_star)
sqrt_term <- sqrt(b^2 - 4 * a * c)
ret$Aj <- (-b + sqrt_term) / (2 * a)
for (i in seq_along(envs$C_i)) {
Amin[i] <- min(ret$Ac[i], ret$Aj[i])
limiting_factor[i] <- c("Ac", "Aj")[which.min(c(ret$Ac[i], ret$Aj[i]))]
}
ret = list()
Amin <- numeric(length(envs$C_i))
limiting_factor <- character(length(envs$C_i))
ret$Ac <- numeric(length(envs$C_i))
ret$Aj <- numeric(length(envs$C_i))
J = 0.24 * envs$PPFD / sqrt(1 + (0.24 * envs$PPFD/pars$J_max)^2)
for (i in 1:length(envs$C_i)) {
Cc_guess <- envs$C_i[i]
continue <- TRUE
iter <- 0
while (continue & iter<=1000){
Ac <- pars$V_cmax * (Cc_guess - pars$gamma_star) / (Cc_guess + (pars$K_C * (1 + envs$O[i] / pars$K_O)))
Aj <- J[i] * (Cc_guess - pars$gamma_star) / (4 * (Cc_guess + 2 * pars$gamma_star))
A_new <- min(Ac, Aj) - pars$R_d
Cc_new <- envs$C_i[i] - A_new / pars$gm
if (abs(Cc_new - Cc_guess) < 0.001){
continue <- FALSE
}else{
Cc_guess <- Cc_new
iter <- iter+1
}
}
Amin[i] <- A_new
ret$Ac[i] <- Ac
ret$Aj[i] <- Aj
limiting_factor[i] <- c("Ac", "Aj")[which.min(c(ret$Ac[i], ret$Aj[i]))]
}
iter
for (i in 1:length(envs$C_i)) {
Cc_guess <- envs$C_i[i]
continue <- TRUE
iter <- 0
while (continue & iter<1000){
Ac <- pars$V_cmax * (Cc_guess - pars$gamma_star) / (Cc_guess + (pars$K_C * (1 + envs$O[i] / pars$K_O)))
Aj <- J[i] * (Cc_guess - pars$gamma_star) / (4 * (Cc_guess + 2 * pars$gamma_star))
A_new <- min(Ac, Aj) - pars$R_d
Cc_new <- envs$C_i[i] - A_new / pars$gm
if (abs(Cc_new - Cc_guess) < 0.001){
continue <- FALSE
}else{
Cc_guess <- Cc_new
iter <- iter+1
}
}
if (iter==999){
Amin[i] <- NA_real_
ret$Ac[i] <- NA_real_
ret$Aj[i] <- NA_real_
limiting_factor[i] <- "Failed"
}else{
Amin[i] <- A_new
ret$Ac[i] <- Ac
ret$Aj[i] <- Aj
limiting_factor[i] <- c("Ac", "Aj")[which.min(c(ret$Ac[i], ret$Aj[i]))]
}
}
ret$An = Amin
ret$Limitation <- limiting_factor
View(ret)
source("~/GitHub/FvCBestimation/R/load_FvCBmodels.R", echo = TRUE)
source("~/GitHub/FvCBestimation/analysis_code/sample_models_scenario1.R", echo = TRUE)
View(ret)
source("~/GitHub/FvCBestimation/analysis_code/sample_models_scenario1.R", echo = TRUE)
View(result_arrays)
result_arrays[["Harley (1992)"]]
